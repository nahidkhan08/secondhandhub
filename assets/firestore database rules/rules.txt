rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /* ======== Products (unchanged) ======== */
    match /products/{productId} {
      allow read: if true;

      allow create: if
        request.auth != null &&
        request.resource.data.title is string &&
        request.resource.data.title.size() >= 3 &&
        request.resource.data.title.size() <= 100 &&
        request.resource.data.price is number &&
        request.resource.data.price > 0 &&
        request.resource.data.description is string &&
        request.resource.data.description.size() >= 10 &&
        request.resource.data.sellerId == request.auth.uid &&
        request.resource.data.status == "active" &&
        request.resource.data.images is list &&
        request.resource.data.images.size() >= 1 &&
        request.resource.data.images.size() <= 5;

      allow update: if
        resource.data.sellerId == request.auth.uid &&
        request.resource.data.keys().hasOnly([
          'title',
          'price',
          'description',
          'images',
          'status',
          'condition'
        ]);

      allow delete: if resource.data.sellerId == request.auth.uid;
    }

    /* ======== Users (unchanged) ======== */
    match /users/{userId} {
      allow read: if true;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    /* ======== Chats (new) ======== */
    match /chats/{chatId} {
      // Read: only participants
      allow read: if request.auth != null &&
                  (request.auth.uid in resource.data.participants);

      // Create: must be logged in, be one of the participants, and only allowed fields
      allow create: if request.auth != null &&
        request.resource.data.keys().hasOnly(['participants','productId','productTitle','createdAt']) &&
        request.resource.data.participants is list &&
        request.resource.data.participants.size() == 2 &&
        request.resource.data.participants[0] is string &&
        request.resource.data.participants[1] is string &&
        (request.auth.uid in request.resource.data.participants) &&
        request.resource.data.productId is string &&
        request.resource.data.productId.size() >= 1 &&
        request.resource.data.productTitle is string &&
        request.resource.data.productTitle.size() >= 1;

      // Update: only participants, and only whitelist fields
      allow update: if request.auth != null &&
        (request.auth.uid in resource.data.participants) &&
        request.resource.data.keys().hasOnly([
          'participants','productId','productTitle','createdAt','lastMessage','updatedAt'
        ]);

      // Delete: only participants
      allow delete: if request.auth != null &&
        (request.auth.uid in resource.data.participants);

      /* ----- Messages subcollection ----- */
      match /messages/{messageId} {
        // Read: only participants of the parent chat
        allow read: if request.auth != null &&
          (request.auth.uid in
            get(/databases/$(database)/documents/chats/$(chatId)).data.participants);

        // Create: only participants; strict field validation
        allow create: if request.auth != null &&
          (request.auth.uid in
            get(/databases/$(database)/documents/chats/$(chatId)).data.participants) &&
          request.resource.data.keys().hasOnly(['text','senderId','timestamp']) &&
          request.resource.data.text is string &&
          request.resource.data.text.size() > 0 &&
          request.resource.data.text.size() <= 1000 &&
          request.resource.data.senderId == request.auth.uid;

        // No edits/deletes to messages (can open later if needed)
        allow update, delete: if false;
      }
    }
  }
}
